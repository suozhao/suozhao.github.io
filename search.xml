<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Babel]]></title>
    <url>%2F2018%2F03%2F13%2FBabel%2F</url>
    <content type="text"><![CDATA[Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。ECMAScript 6是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。但是目前浏览器对es6不完全兼容，需要借住babel编译。 配置文件通过 .babelrc 来配置Babel 转码规则，放在项目根目录下 /.babelrc1234&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: []&#125; 上面配置了 Babel 转码规则为，将ES6的语法转为ES2015的转码，支持React的JSX语法转码，使用 stage-2 模式转码（相关模式下面会详细介绍） Babel 通过三个步骤 语法解析-转码-生成文件来编译Javascript。 Babel 是通过一系列插件来完成对JS的编译。 stage-x 是对非标准或未定案的标准的API的转码实现 Presetspresets 是Babel内置的一些预设，是一系列插件的组合。 官方预设 Official Presets env 根据配置的环境自动加载相关的插件 es2015 将ES6的语法转码为ES5的语法 es2016幂运算语法糖插件 2**3 =&gt; 2*2*2 es2017 Async / Await / Generator react 支持React编译 flow 支持静态类型检测编译 Babel-polyfill针对默认不转换的API，需要另外添加一个Polyfill，或针对某个API添加插件。 Babel 默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在 Array 对象上新增了 Array.from 方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill，为当前环境提供一个垫片。1npm install --save-dev babel-polyfill babel-polyfill 提提供了对新的标准API的支持，兼容老的版本。 下列特性需要使用 babel-polyfill 才能转码，或者单独引用相关插件 123456789101112131415161718192021222324252627282930313233343536373839404142// 数组操作ArrayBufferArray.fromArray.ofArray#copyWithinArray#fillArray#findArray#findIndexFunction#name// 数学方法Math.acoshMath.hypotMath.imul// 数字类型的扩展方法Number.isNaNNumber.isInteger// 对象的扩展方法Object.assignObject.getOwnPropertyDescriptorsObject.isObject.entriesObject.valuesObject.setPrototypeOfPromiseReflectRegExp#flags// 字符串的扩展方法String#codePointAtString#endsWithString.fromCodePointString#includesString.rawString#repeatString#startsWithString#padStartString#padEnd// 新扩展的数据类型MapSetSymbolWeakMapWeakSet 使用123import &apos;babel-polyfill&apos;;// 或者require(&apos;babel-polyfill&apos;); Stage说明Babel的转换级别依据 ES7不同阶段的语法提案设置了4个阶段：stage-0 、stage-1、stage-2、stage-3，使用时选装一个。（0的级别最高，包含的转码插件最多，往后越来越少） stage-0提供ES7的支持 包含 stage-1、stage-2、stage-3 的内容 特有的插件 transform-do-expressions transform-function-bind transform-do-expressions 支持 模板中使用if else12345678910111213&lt;div className=&quot;parents&quot;&gt;&#123; do &#123; if(color == &apos;blue&apos;) &#123; &lt;BlueComponent/&gt;; &#125;else if(color == &apos;red&apos;) &#123; &lt;RedComponent/&gt;; &#125;else &#123; &lt;GreenComponent/&gt;; &#125; &#125; &#125;&#125;&lt;/div&gt; transform-function-bind 绑定上下文 1234567891011121314151617181920212223242526272829303132// 语法obj::func // func.bind(obj)obj::func(val) // func.call(obj, val)::obj.func(val) // func.call(obj, val)// 基本用法const box = &#123; weight: 2, getWeight() &#123; return this.weight; &#125;,&#125;;const &#123; getWeight &#125; = box;console.log(box.getWeight()); // prints &apos;2&apos;const bigBox = &#123; weight: 10 &#125;;console.log(bigBox::getWeight()); // prints &apos;10&apos;// Can be chained:function add(val) &#123; return this + val; &#125;console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos;// 处理Nodelist(Array Like 类型)const &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll(&apos;a&apos;) ::map(node =&gt; node.href) ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);console.log(sslUrls);// is equivalent toconst &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll(&apos;a&apos;);sslUrls = map.call(sslUrls, node =&gt; node.href);sslUrls = filter.call(sslUrls, href =&gt; href.substring(0, 5) === &apos;https&apos;);console.log(sslUrls);//绑定自身$(&apos;.some-link&apos;).on(&apos;click&apos;, ::view.reset);// is equivalent to:$(&apos;.some-link&apos;).on(&apos;click&apos;, view.reset.bind(view)); stage-1包含 stage-2 、stage-3 提供对 类的静态、实例属性和方法的支持 以及 对模块导入方式的扩展 特有插件 transform-class-properties transform-export-extensions transform-class-properties 支持 123456789101112class Bork &#123; //Property initializer syntax instanceProperty = &quot;bork&quot;; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = &quot;babelIsCool&quot;; static staticFunction = function() &#123; return Bork.staticProperty; &#125;&#125; transform-class-properties 支持 12export * as ns from &apos;mod&apos;;export v from &apos;mod&apos;; stage-2包含 stage-3 提供尾逗号函数功能 及 支持 Object 使用延展符展开 特有插件 syntax-trailing-function-commas transform-object-reset-spread syntax-trailing-function-commas 添加行尾逗号，减少文件的改动12345678function clownPuppiesEverywhere( param1, param2,) &#123; /* ... */ &#125;clownPuppiesEverywhere( &apos;foo&apos;, &apos;bar&apos;,); transform-object-reset-spread 支持使用展开符展开对象1234567let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(x); // 1console.log(y); // 2console.log(z); // &#123; a: 3, b: 4 &#125;// 属性展开let n = &#123; x, y, ...z &#125;;console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125; stage-3提供对ES7的async和await的支持 及提供幂操作的语法糖 特有插件 transform-async-to-generator transform-exponentiation-operator transform-async-to-generator 转码ES7的 async与await12345678910111213141516//inasync function* agf() &#123; await 1; yield 2;&#125;//outvar _asyncGenerator = ...let agf = (() =&gt; &#123; var _ref = _asyncGenerator.wrap(function* () &#123; yield _asyncGenerator.await(1); yield 2; &#125;); return function agf() &#123; return _ref.apply(this, arguments); &#125;;&#125;)(); transform-exponentiation-operator 支持幂运算语法糖 **12345// x ** ylet squared = 2 ** 2;// 相当于: 2 * 2let cubed = 2 ** 3;// 相当于: 2 * 2 * 2 为了防止某些实验中的标准在未来不能定案，一般使用 stage-1 或 stage-2 来进行转码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-flow]]></title>
    <url>%2F2018%2F03%2F12%2Fwebpack-flow%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[关于继承继承，代码复用的一种模式。和其它高级程序语言相比，javascript有点点不一样，它是一门纯面向对象的语言，在JS中，没有类的概念，但也可以通过原型(prototype)来模拟对象的继承和多态。 原型与实例 一切对象都是Object的实例，一切函数都是Function的实例 构造函数通过 prototype 属性访问原型对象 实例对象通过 [[prototype]] 内部属性访问原型对象，浏览器实现了 proto 属性用于实例对象访问原型对象 Object 是构造函数，既然是函数，那么就是Function的实例对象；Function是构造函数，但Function.prototype是对象，既然是对象，那么就是Object的实例对象关系判断 instanceof 判断是否为另一个对象的实例 isPrototypeOf() 判断一个对象是否存在于另一个对象的原型链上 Child.isPrototypeOf(Parent) // true Object.getPrototypeOf() ES6中新增的方法，用于获取子类的父类 Object.getPrototypeOf(Child) == Parent // true继承类型 引用对象继承：子引用类型继承父引用类型，然后通过子引用类型生成的实例对象，具有父引用类型的特性。 实例对象继承：而实例对象继承，继承得到的对象都具有父实例对象的所有属性和方法，其实就是指对象的复制和克隆。引用对象继承 原型 （C.prototype = new P()） 构造函数 (P.apply(this, arguments)) 原型 + 构造函数 (使用原型链实现对原型中的属性方法的继承，使用构造函数实现实例属性的继承) 共享原型（子类与父类共享同一个原型） 临时原型（使用中间类） 临时原型 + 构造函数（完美、nodejs的继承方式、ES5版本）原型继承让子类的的原型等于父类的实例，从而继承父类的所有属性和原型1234567891011121314151617181920212223242526272829function Parent()&#123; this.name = &apos;father&apos;; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123;&#125;Person.prototype = new Parent();Person.prototype.constructor = Person;var p1 = new Person();var p2 = new Person();console.log(p1.name); // fatherconsole.log(p2.name); // fatherp1.name = &apos;jack&apos;;p2.name = &apos;mak&apos;;console.log(p1.name); // jackconsole.log(p2.name); // makconsole.log(p1.say()) // jack,[&quot;A&quot;, &quot;B&quot;]console.log(p2.say()) // mak,[&quot;A&quot;, &quot;B&quot;]console.log(&apos;====================&apos;)console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;]p1.friends.push(&apos;C&apos;);p1.friends.push(&apos;D&apos;);console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p1.say()) //jack,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.say()) //mak,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] 缺点： 不能向父类的构造函数中传递参数 父类中的引用类型属性会被实例共享 需要修正实例的constructor指向，否则会指向父类构造函数继承在子类的构造函数中使用 Parent.call(this, …args) 或 Parent.apply(this,[args]) 来继承父类的属性，并向父类的构造函数传参1234567891011121314151617181920function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123; Parent.apply(this, arguments); this.age = 23;&#125;var p1 = new Person(&apos;nameA&apos;);var p2 = new Person(&apos;nameB&apos;);console.log(p1.name); //nameAconsole.log(p2.name); //nameBp1.friends.push(&apos;C&apos;);p2.friends.push(&apos;D&apos;);console.log(p1.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]console.log(p2.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(p1.say()) // Uncaught TypeError: p1.say is not a function 优点：子类可以向父类的构造函数中传参，子类实例中的引用类型属性互不干扰 缺点：子类实例无法访问父类的原型（无法复用父类原型中的方法）原型+构造函数继承为解决纯原型继承不能给父传参和纯构造函数继承不能继承父类原型的缺点，把二者结合起来实现123456789101112131415161718192021222324252627function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; Parent.call(this, name); this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.see = function()&#123; console.log(this.age);&#125;Child.prototype.getAge = () =&gt; this.age;var c1 = new Child(&apos;jack&apos;,12);c1.friends.push(&apos;F&apos;);console.log(c1.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;F&quot;]console.log(c1.see()); //12var c2 = new Child(&apos;jack&apos;,42);c2.friends.push(&apos;D&apos;);console.log(c2.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(c2.see()); //42 缺点：子类初次实例化时会多调用一个父类的构造函数（第一次创建子类原型和子类实例化时） 共享原型子类和父类共用一个原型123456789101112131415161718192021function inherit(C, P)&#123; C.prototype = P.prototype;&#125;function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype.say=()=&gt;console.log(&apos;child&apos;,this.name);inherit(Child, Parent);var c1 = new Child(&apos;pake&apos;, 44);c1.name = &apos;jack&apos;;console.log(c1.name) //jackconsole.log(c1.say()) //jack,undefined 缺点：子类实例化时，父类构造函数接收不到参数， 子类原型如果改变也会影响到父类原型 临时原型使用一个纯净类继承父类的原型，再将纯净类的实例设置为子类的原型，如此子类继承了父类的原型和纯净类的构造函数，再修正一下子类的构造函数为子类本身，这样子类的原型改动就不影响父类。12345678910111213141516171819202122function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack undefined 缺点：只继承了父类的原型，子类实例化时一样不能给父类的构造函数传参 临时原型 + 构造函数在子类的构造函数中调用父类的构造函数，修复了上面 临时原型 不能传递参数给父类构造函数的问题123456789101112131415161718192021222324252627282930313233343536373839404142function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; Parent.call(this, age); this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack 10// 这种方法是最合适，也是用得最广的继承模式另一种相同的实现，ES5的实现function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info(&quot;Shape moved.&quot;);&#125;;function Rectangle() &#123; Shape.call(this); //call super constructor.&#125;Rectangle.prototype = Object.create(Shape.prototype);var rect = new Rectangle();console.log(rect instanceof Rectangle); //true.console.log(rect instanceof Shape); //true.rect.move(); //&quot;Shape moved.&quot; 实例对象继承原型实例创建一个继承父类原型的实例对象，这也是ES5中Object.create()的简单实现12345678910111213141516function object(P)&#123; var F = function()&#123;&#125;; F.prototype = P; return new F();&#125;function Parent(name) &#123; this.name = name || &apos;Adam&apos;;&#125;Parent.prototype.say = function()&#123; console.log(this.name)&#125;;var c1 = new Parent(&apos;jack&apos;);var c2 = object(c1);c2.name = &apos;mark&apos;;console.log(c1.say()) //jackconsole.log(c2.say()) //mark 克隆浅拷贝只能拷贝值类型的数据，对于引用类型，只会拷贝引用地址，如果有引用类型，多个拷贝对象会共用同一个引用类型的数据，造成混乱。123456789101112function clone(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; parent.hasOwnProperty(i) &amp;&amp; (child[i] = parent[i]); &#125; return child;&#125;var o1 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o2 = clone(o1);o2.arr.push(3);console.log(o1.arr); //[1, 2, 4, 3]console.log(o2.arr); //[1, 2, 4, 3] 两个拷贝对象共用同一个引用类型，会相互影响 深拷贝12345678910111213141516171819function cloneDeep(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i]===&apos;object&apos;)&#123; child[i] = Array.isArray(parent[i]) ? []:&#123;&#125;; cloneDeep(parent[i], child[i]); &#125;else&#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125;var o3 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o4 = cloneDeep(o3);o4.arr.push(3);console.log(o3.arr);//[1, 2, 4]console.log(o4.arr);//[1, 2, 4, 3] 两个对象引用不同的引用地址，互不影响 借用和绑定使用 call / apply / bind 复用对象上的方法12345678910111213141516171819202122232425var parent = &#123; name:&apos;parent&apos;, say:function(msg)&#123; console.log(this.name, msg) &#125;&#125;var child = &#123; name:&apos;child&apos;&#125;// 复用父类的say方法parent.say.call(child, &apos;hello&apos;); //child helloparent.say.bind(child, &apos;world&apos;)(); //child world// bind的内部实现if(typeof Function.prototype.bind === &apos;undefined&apos;)&#123; Function.prototype.bind = function(context)&#123; var _this = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function()&#123; return _this.apply(context, args.concat(slice.call(arguments))); &#125; &#125;&#125;// 借用Array中的slice方法// Array.prototype.slice.call() 与 [].prototype.slice.call() 区别: 前者写法长，但少一个创建数组实例的开销 ES6的继承方式使用 extends 关键字，来实现继承123456789101112131415161718192021222324252627282930class Parent &#123; static name = &apos;parent&apos;; //静态属性 work = &apos;aa&apos;; //实例属性&#125;class Child extends Parent &#123; constructor(age)&#123; super(age); // 在此必须先调用super()，否则子类实例化时会报错，因为子类没有自己的this对象，而是继承父类的this对象 this.age = age; &#125; say()&#123; console.log(&apos;child say&apos;, this.age); &#125; // 通过 static 关键字标识类的静态方法 static work()&#123; console.log(&apos;child working&apos;) &#125;&#125;Child.work(); //child workingvar c1 = new Child(16);console.log(c1.say());//child say 16// 如果子类中没有 constructor 方法，ES6 会默认添加这个方法constructor(...args)&#123; super(...args);&#125;class A extends Object&#123;&#125;A.__proto__ === Object //trueclass B extends Array&#123;&#125;var arrB = new B();b.push(1); //[1]b.length; //1 ES5继承 是先创建子类的实例对象this，再向this对象中添加父类的方法 ES6继承 是先创造父类的实例对象this, 再用子类的构造函数修改this Parent 可以是任意函数（只要有prototype属性）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.create与new的不同]]></title>
    <url>%2F2018%2F02%2F08%2FObject-create%E4%B8%8Enew%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。 语法1new constructor[([arguments])] 参数constructor一个指定对象实例的类型的函数。 arguments一个用来被constructor 调用的参数列表。 描述创建一个用户自定义的对象需要两步： 1.定义构造函数。2.通过new来创建对象实例。 创建一个对象类型需要创建一个指定了名称和属性的函数；其中这些属性可以指向它本身，也可以指向其他对象，看下面的例子： 当代码 new Foo(…) 执行时： 1.一个新对象被创建。它继承自Foo.prototype。2.使用指定的参数调用构造函数Foo，并将 this绑定到新创建的对象。new Foo 等同于 new Foo()，只能用在Foo 不传递任何参数的情况。3.如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。） 任何情况下都可以对任意一个对象添加新的属性，例如 car1.color = “black” 语句给car1添加了一个新的属性color , 然后给这个属性赋值 “black”。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，必须将该属性添加到Car对象类型的定义中。 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 语法1Object.create(proto[, propertiesObject]) 参数proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值在指定原型对象上添加新属性后的对象。 例外如果proto参数不是 null 或一个对象，则抛出一个 TypeError 异常。 以上是MDN上对new操作符和Object.create的定义 下面再来看看执行这两个操作分别都做了什么12//new 操作符var a = new Foo(); 1234const o = new Object();//创建了一个新的空对象oo.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`Foo.call(o);//this指向o对象a = o;//将o对象赋给a对象 12//Object.createvar a = Object.create(Foo); 12345Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F();&#125;; 当看到结果的时候我是一脸懵逼,属性和原型方法都没有继承下来!!! 没事,咱们来画个图 这下就清楚了,在用Object.create创建的对象b把__proto__指向了Foo构造函数本身,再回来理解MDN的定义就明白了 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 1b.__proto__ === Foo //true 总结：1.Object.create在创建新对象时把__proto__指向了传进来的参数对象，这个参数可以是任何对象。而new操作符只能是由构造函数创建对象。2.new操作符会在执行过程中调用构造函数并把this指向新对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 7配置samba]]></title>
    <url>%2F2018%2F02%2F08%2FcentOS%207%E9%85%8D%E7%BD%AEsamba%2F</url>
    <content type="text"><![CDATA[（以下内容均来自网络学习） root用户执行 安装Samba12yum -y install samba samba-client samba-common rpm -qi samba可以查看samba版本信息 12345678910111213141516171819202122[root@MiWiFi-R1CM-srv samba]# rpm -qi sambaName : sambaEpoch : 0Version : 4.2.10Release : 6.2.el7_2Architecture: x86_64Install Date: Tue 19 Jul 2016 03:26:55 AM CSTGroup : System Environment/DaemonsSize : 1895784License : GPLv3+ and LGPLv3+Signature : RSA/SHA256, Fri 24 Jun 2016 04:12:11 AM CST, Key ID 24c6a8a7f4a80eb5Source RPM : samba-4.2.10-6.2.el7_2.src.rpmBuild Date : Fri 24 Jun 2016 02:38:45 AM CSTBuild Host : worker1.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor : CentOSURL : http://www.samba.org/Summary : Server and Client software to interoperate with Windows machinesDescription :Samba is the standard Windows interoperability suite of programs for Linux and Unix.[root@MiWiFi-R1CM-srv samba]# 设置开机启动：1systemctl enable smb.service 查看是否设置成功1systemctl status smb.service 启动samba服务1systemctl start smb.service 再次查看启动状态1systemctl status smb.service 1234567891011121314151617[root@MiWiFi-R1CM-srv samba]# systemctl status smb.service● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2016-07-19 03:32:36 CST; 12min ago Main PID: 27455 (smbd) Status: &quot;smbd: ready to serve connections...&quot; CGroup: /system.slice/smb.service ├─27455 /usr/sbin/smbd ├─27460 /usr/sbin/smbd └─27601 /usr/sbin/smbdJul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Starting Samba SMB Daemon...Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: smb.service: Supervising process 27455 which is not our child. We&apos;ll most likely not n... exits.Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Started Samba SMB Daemon.Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: [2016/07/19 03:32:36.184968, 0] ../lib/util/become_daemon.c:124(daemon_ready)Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: STATUS=daemon &apos;smbd&apos; finished starting up and ready to serve connectionsHint: Some lines were ellipsized, use -l to show in full.[root@MiWiFi-R1CM-srv samba]# 配置配置文件进入目录：1cd /etc/samba 备份：1# cp smb.conf smb.conf.backup 修改smb.conf文件，找到“[homes]”，修改以下设置：12345678910111213[global] log file = /var/log/samba/log.%m load printers = yes cups options = raw server string = Samba Server Version %v writeable = yes force directory mode = 777 force create mode = 777 workgroup = MYGROUP security = user create mode = 777 passdb backend = tdbsam max log size = 50 新版的samba放在smb.conf最后是无效的 添加用户1smbpasswd -a username 如果出现bash: smbpasswd: command not found，就是没有安装samba-client了 附： smbpasswd命令的常用方法123456789smbpasswd -a 增加用户（要增加的用户必须以是系统用户）smbpasswd -d 冻结用户，就是这个用户不能在登录了smbpasswd -e 恢复用户，解冻用户，让冻结的用户可以在使用smbpasswd -n 把用户的密码设置成空.要在global中写入 null passwords -truesmbpasswd -x 删除用户 selinux设置12getsebool -a | grep sambasetsebool -P samba_enable_home_dirs on 防火墙，使用新的防火墙firewall添加就可以，比iptables更方便1234firewall-cmd --list-servicesfirewall-cmd --permanent --add-service=sambafirewall-cmd --reloadfirewall-cmd --list-services 由于redhat7开始，iptables被firewalld代替了，所以使用firewalld的方法 关于firewalld的说明，可以看fedora官网介绍 https://fedoraproject.org/wiki/FirewallD/zh-cn 1重启samba服务1systemctl restart smb.service]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数运算初探]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[之前再做大数运算的时候在网上查到一个高大上的方法1234567891011function sumStrings(a,b)&#123; var res=&apos;&apos;, c=0; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c)&#123; c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c&gt;9; &#125; return res.replace(/^0+/,&apos;&apos;);&#125; 逼格满满 虽然之前也见过这些操作符,但是一直都没有研究过,今天就来了解一下先来看看~是什么 位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。 位运算 NOT 是三步的处理过程： 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 举个栗子：~8 =&gt; 1000 =&gt; 取反 =&gt; 符号位为1 0111 =&gt; 负数取反符号位不变 =&gt; 符号位1 1000 =&gt; 补码 =&gt; 符号位1 1001 =&gt; -9 在MDN查到这么一句 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 这对之后的运算就可以省去很多步骤了 再回来看上面的add方法大致的逻辑是 字符串转成数组,每位一个元素 然后把数组最后一位揪出来 做两次取反的计算 因为位运算会对运算数转成32位数字，所以根据尝试对~操作前的流程做了一定的猜测首先先对运算数进行隐式的转换Nuber()，如果是NaN的话会转成0 经过查看规范证实上面的猜测 所以经过取反以后,数字字符串会直接转成数字，undefined会直接转成0，就可以进行下面的计算了 经过测试呢，~~确实比Math.floor性能强那么有限的一点12345678910111213console.time(&apos;~&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; ~~14.14;&#125;console.timeEnd(&apos;~&apos;)~: 2.107177734375msconsole.time(&apos;Math.floor&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; Math.floor(14.14)&#125;console.timeEnd(&apos;Math.floor&apos;)Math.floor: 3.206787109375ms 总结：装逼神器]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http缓存机制]]></title>
    <url>%2F2018%2F05%2F04%2Fhttp%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[http报文中与缓存相关的首部字段我们先来瞅一眼RFC2616规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底： 通用首部字段（就是请求报文和响应报文都能用上的字段） 字段 说明 Cache-Control 控制缓存的行为 Pragma http1.0的旧社会遗留物,值为”no-cache”时禁用缓存 请求首部字段 字段 说明 if-Match 比较ETag是否一致 if-None-Match 比较ETag是否不一致 if-Modified-Since 比较资源最后更新的事件是否一致 if-Unmodified-Since 比较资源最后更新的事件是否不一致 响应首部字段 字段 说明 ETag 资源的匹配信息 实体首部字段 字段 说明 Expires http1.0的遗留物,实体主体过期的时间 Last-Modified 资源的最后一次修改的时间 后续大体也会依次介绍它们。 场景模拟为方便模拟各种缓存效果，我们建个非常简单的场景。 页面文件我们建个非常简单的html页面，上面只有一个本地样式文件和图片：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;缓存测试&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/reset.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;哥只是一个标题&lt;/h1&gt; &lt;p&gt;&lt;img src=&quot;img/dog.jpg&quot; /&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 首部字段修改有时候一些浏览器会自行给请求首部加上一些字段（如chrome使用F5会强制加上“cache-control:max-age=0”）,会覆盖掉一些字段（比如pragma）的功能；另外有时候我们希望服务器能多少返回一些响应字段。这种情况我们就希望可以手动来修改请求或响应报文上的内容了。那么如何实现呢？这里我们使用Fiddler来完成任务。在Fiddler中我们可以通过“bpu XXX”指令来拦截指定请求，然后手动修改请求内容再发给服务器、修改响应内容再发给客户端。以我们的example为例，页面文件走nginx通过 http://localhost/ 可直接访问，所以我们直接执行“bpu localhost”拦截所有地址中带有该字样的请求：点击被拦截的请求，可以在右栏直接修改报文内容（上半区域是请求报文，下半区域是响应报文），点击黄色的“Break on Response”按钮可以执行下一步（把请求发给服务器），点击绿色的按钮“Run to Completion”可以直接完成整个请求过程：通过这个方法我们可以很轻松地模拟出各种http缓存场景。 浏览器的强制策略如上述，当下大多数浏览器在点击刷新按钮或按F5时会自行加上“Cache-Control:max-age=0”请求字段，所以我们先约定成俗——后文提及的“刷新”多指的是选中url地址栏并按回车键（这样不会被强行加上Cache-Control）。事实上有的浏览器还有一些更奇怪的行为，在后续我们回答文章开头问题的时候会提到。 石器时代的缓存方式在 http1.0 时代，给客户端设定缓存方式可通过两个字段——“Pragma”和“Expires”来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。 Pragma当该字段值为“no-cache”的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（而且可能还得做些hack放到body后面去）：1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行。BUT!!! 事实上这种禁用缓存的形式用处很有限： 仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别“Cache-Control: no-store”的meta标签（见出处）。 在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。 做了测试后发现也的确如此，这种客户端定义Pragma的形式基本没起到多少作用。不过如果是在响应报文上加上该字段就不一样了：如上图红框部分是再次刷新页面时生成的请求，这说明禁用缓存生效，预计浏览器在收到服务器的Pragma字段后会对资源进行标记，禁用其缓存行为，进而后续每次刷新页面均能重新发出请求而不走缓存。 Expires有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：1&lt;meta http-equiv=&quot;expires&quot; content=&quot;mon, 18 apr 2016 14:30:00 GMT&quot;&gt; 如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间：在上图里，缓存时间设置为一个已过期的时间点（见红框），则刷新页面将重新发送请求（见蓝框）。那么如果Pragma和Expires一起上阵的话，听谁的？我们试一试就知道了：我们通过Pragma禁用缓存，又给Expires定义一个还未到期的时间（红框），刷新页面时发现均发起了新请求（蓝框），这意味着Pragma字段的优先级会更高。BUT，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。 Cache-Control针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。Cache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：1&quot;Cache-Control&quot; &quot;:&quot; cache-directive 作为请求首部时，cache-directive 的可选值有： 字段 说明 no-cache 告知服务器不直接使用缓存,要求向原服务器发起请求 no-store 所有内容都不会被保存到缓存或Internet临时文件中 max-age=delta-seconds 告知服务器客户端希望接收一个存在时间(Age)不大于delta-seconds秒的资源 max-stale[=delta-seconds] 告知服务器,客户端愿意接受一个超过缓存时间的资源,若有定义delta-seconds则为delta-seconds秒,若没有则为任意超出的时间 min-fresh=delta-seconds 告知服务器,客户端希望接受一个在小于delta-seconds秒内被更新过的资源 only-if-cached 告知服务器,客户端希望获取缓存的内容(若有),而不用向原服务器发请求 cache-extension 自定义扩展值,若服务器不识别该值将被忽略掉 作为响应首部时，cache-directive 的可选值有： 字段 说明 public 表明任何情况下都得缓存该资源 Private[=”field-name”] 表明返回报文中全部或部分(若制定了field-name则为field-name的字段数据)仅开放给某些用户(服务器指定的share-user)做缓存使用,其他用户则不能缓存这些数据 no-cache 不直接使用缓存,要求向服务器发起(新鲜度校验)请求 no-store 所有内容都不会被保存到缓存或Internet临时文件中 no-transform 告知客户端缓存文件时不得对实体数据做任何改变 only-if-cached 告知服务器,客户端希望获取缓存的内容(若有),而不用向原服务器发请求 must-revalidate 当前资源一定是向原服务器发验证请求的,若请求失败会返回504(而非代理服务器上的缓存) proxy-revalidate 与must-revalidate类似,但仅能应用于共享缓存 max-age=delta-sconds 告知客户端该资源在delta-seconds秒内是新鲜的,无需向服务器发请求 s-maxage=delta-seconds 同max-age,但仅应用于共享缓存 cache-extension 自定义扩展值,若服务器不识别该值将被忽略 我们依旧可以在HTML页面加上meta标签来给请求报头加上 Cache-Control 字段：另外 Cache-Control 允许自由组合可选值，例如：1Cache-Control: max-age=3600, must-revalidate 它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：1Cache-Control: no-cache, no-store 缓存校验字段上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。 我们现在要说的问题是，如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？ 我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？ 答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。 为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。 Last-Modified服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。 客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。 至于传递标记起来的最终修改时间的请求报文首部字段一共有两个： If-Modified-Since: Last-Modified-value1If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT 该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。 If-Unmodified-Since: Last-Modified-value告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。 当遇到下面情况时，If-Unmodified-Since 字段会被忽略：1231. Last-Modified值对上了（资源在服务端没有新的修改）；2. 服务端需返回2XX和412之外的状态码；3. 传来的指定日期不合法 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。__ ETag为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 ETag 实体首部字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。 客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 那么客户端是如何把标记在资源上的 ETag 传去给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值： If-None-Match: ETag-value1If-None-Match: &quot;56fcccc8-1699&quot; 告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。 If-Match: ETag-value告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。 If-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。 需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。 如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。在较新的 nginx 上默认是同时开启了这两个功能的：上图的前三条请求是原始请求，接着的三条请求是刷新页面后的新请求，在发新请求之前我们修改了 reset.css 文件，所以它的 Last-Modified 和 ETag 均发生了改变，服务器因此返回了新的文件给客户端（状态值为200）。 而 dog.jpg 我们没有做修改，其Last-Modified 和 ETag在服务端是保持不变的，故服务器直接返回了304状态码让客户端直接使用缓存的 dog.jpg 即可，没有把实体内容返回给客户端（因为没必要）。 缓存实践当我们在一个项目上做http缓存的应用时，我们还是会把上述提及的大多数首部字段均使用上，例如使用 Expires 来兼容旧的浏览器，使用 Cache-Control 来更精准地利用缓存，然后开启 ETag 跟 Last-Modified 功能进一步复用缓存减少流量。 那么这里会有一个小问题——Expires 和 Cache-Control 的值应设置为多少合适呢？ 答案是不会有过于精准的值，均需要进行按需评估。 例如页面链接的请求常规是无须做长时间缓存的，从而保证回退到页面时能重新发出请求，百度首页是用的 Cache-Control:private，腾讯首页则是设定了60秒的缓存，即 Cache-Control:max-age=60。 而静态资源部分，特别是图片资源，通常会设定一个较长的缓存时间，而且这个时间最好是可以在客户端灵活修改的。以腾讯的某张图片为例： 1http://i.gtimg.cn/vipstyle/vipportal/v4/img/common/logo.png?max_age=2592000 客户端可以通过给图片加上“max_age”的参数来定义服务器返回的缓存时间：当然这需要有一个前提——静态资源能确保长时间不做改动。如果一个脚本文件响应给客户端并做了长时间的缓存，而服务端在近期修改了该文件的话，缓存了此脚本的客户端将无法及时获得新的数据。 解决该困扰的办法也简单——把服务侧ETag的那一套也搬到前端来用——页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：123https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.jshttp://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg 如果文件被修改了，才更改其标记符内容，这样能确保客户端能及时从服务器收取到新修改的文件。 总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[小程序组件通信]]></title>
    <url>%2F2018%2F03%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件与组件behaviors定义和使用 behaviorsbehaviors 是用于组件间代码共享的特性，类似于一些编程语言中的“mixins”或“traits”。 每个 behavior 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个 behavior 。 behavior 也可以引用其他 behavior 。 behavior 需要使用 Behavior() 构造器定义。 代码示例：12345678910111213141516// my-behavior.jsmodule.exports = Behavior(&#123; behaviors: [], properties: &#123; myBehaviorProperty: &#123; type: String &#125; &#125;, data: &#123; myBehaviorData: &#123;&#125; &#125;, attached: function()&#123;&#125;, methods: &#123; myBehaviorMethod: function()&#123;&#125; &#125;&#125;) 组件引用时，在 behaviors 定义段中将它们逐个列出即可。 代码示例：1234567891011121314151617// my-component.jsvar myBehavior = require(&apos;my-behavior&apos;)Component(&#123; behaviors: [myBehavior], properties: &#123; myProperty: &#123; type: String &#125; &#125;, data: &#123; myData: &#123;&#125; &#125;, attached: function()&#123;&#125;, methods: &#123; myMethod: function()&#123;&#125; &#125;&#125;) 在上例中， my-component 组件定义中加入了 my-behavior ，而 my-behavior 中包含有 myBehaviorProperty 属性、 myBehaviorData 数据字段、 myBehaviorMethod 方法和一个 attached 生命周期函数。这将使得 my-component 中最终包含 myBehaviorProperty 、 myProperty 两个属性， myBehaviorData 、 myData 两个数据字段，和 myBehaviorMethod 、 myMethod 两个方法。当组件触发 attached 生命周期时，会依次触发 my-behavior 中的 attached 生命周期函数和 my-component 中的 attached 生命周期函数。 字段的覆盖和组合规则组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下： 如果有同名的属性或方法，组件本身的属性或方法会覆盖 behavior 中的属性或方法，如果引用了多个 behavior ，在定义段中靠后 behavior 中的属性或方法会覆盖靠前的属性或方法； 如果有同名的数据字段，如果数据是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖； 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用。如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。 组件与页面组件传值/方法到页面页面中引用组件1&lt;component id&quot;component&quot;&gt;&lt;/component&gt; 12345678//component.jsComponent(&#123; methods: &#123; fun(v)&#123; console.log(v) &#125; &#125;&#125;) 在js中可以这样调用123456Page(&#123; onready()&#123; this.component = this.selectComponent(&quot;#component&quot;); this.component.fun(&quot;value&quot;); &#125;&#125;) 页面传值/方法到组件页面中引用组件1&lt;component id&quot;component&quot; bind:customevent=&quot;cevent&quot;&gt;&lt;/component&gt; 123456//index.jsPage(&#123; cevent(v)&#123; console.log(v) &#125;&#125;) 组件里这样使用12345678910Component(&#123; methods()&#123; fun()&#123; var myEventDetail = &#123;&#125; // detail对象，提供给事件监听函数 var myEventOption = &#123;&#125; // 触发事件的选项 this.triggerEvent(&apos;customevent&apos;, myEventDetail, myEventOption) //triggerEvent函数接受三个值：事件名称、数据、选项值 &#125; &#125;&#125;) 当调用fun（）时，则会执行index.js里的cevent]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式断言]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[正则表达式的先行断言和后行断言一共有4种形式： (?=pattern) 零宽正向先行断言 (?!pattern) 零宽负向先行断言 (?&lt;=pattern) 零宽正向后行断言 (?&lt;!pattern) 零宽负向后行断言这里面的pattern是一个正则表达式。 (?=pattern) 正向先行断言代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。例如对a regular expression这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用re(?=gular)，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为re(?=gular).，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。 (?!pattern) 负向先行断言代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。例如对regex represents regular expression这个字符串，要想匹配除regex和regular之外的re，可以用re(?!g)，该表达式限定了re右边的位置，这个位置后面不是字符g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。 (?&lt;=pattern) 正向后行断言代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。例如对regex represents regular expression这个字符串，有4个单词，要想匹配单词内部的re，但不匹配单词开头的re，可以用(?&lt;=\w)re，单词内部的re，在re前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。 (?&lt;!pattern) 负向后行断言代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。例如对regex represents regular expression这个字符串，要想匹配单词开头的re，可以用(?&lt;!\w)re。单词开头的re，在本例中，也就是指不在单词内部的re，即re前面不是单词字符。当然也可以用\bre来匹配。 我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用[^…]形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）呢？用[^…]这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。例如判断一句话中包含this，但不包含that。包含this比较好办，一句话中不包含that，可以认为这句话中每个字符的前面都不是that或每个字符的后面都不是that。正则表达式如下：^((?&lt;!that).)*this((?&lt;!that).)*$ 或 ^(.(?!that))*this(.(?!that))*$对于”this is the case”这句话，两个表达式都能够匹配成功，而”note that this is the case”都匹配失败。在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以that开头、以that结尾、that和this连在一起时，上述表达式就可能不胜任了。如note thatthis is the case或者this is the case, not that等。只要灵活运用这几个断言，就很容易解决：1234^(.(?&lt;!that))*this(.(?&lt;!that))*$ ^(.(?&lt;!that))*this((?!that).)*$ ^((?!that).)*this(.(?&lt;!that))*$ ^((?!that).)*this((?!that).)*$ 这4个正则表达式测试上述的几句话，结果都能够满足要求。 上述4种断言，括号里的pattern本身是一个正则表达式。但对2种后行断言有所限制，在Perl和Python中，这个表达式必须是定长(fixed length)的，即不能使用、+、?等元字符，如(?&lt;=abc)没有问题，但(?&lt;=abc)是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持?、{m}、{n,m}等符号，但同样不支持*、+字符。Javascript干脆不支持后行断言，不过一般来说，这不是太大的问题。参见这里。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel]]></title>
    <url>%2F2018%2F03%2F13%2FBabel%2F</url>
    <content type="text"><![CDATA[Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。ECMAScript 6是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。但是目前浏览器对es6不完全兼容，需要借住babel编译。 配置文件通过 .babelrc 来配置Babel 转码规则，放在项目根目录下 /.babelrc1234&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: []&#125; 上面配置了 Babel 转码规则为，将ES6的语法转为ES2015的转码，支持React的JSX语法转码，使用 stage-2 模式转码（相关模式下面会详细介绍） Babel 通过三个步骤 语法解析-转码-生成文件来编译Javascript。 Babel 是通过一系列插件来完成对JS的编译。 stage-x 是对非标准或未定案的标准的API的转码实现 Presetspresets 是Babel内置的一些预设，是一系列插件的组合。 官方预设 Official Presets env 根据配置的环境自动加载相关的插件 es2015 将ES6的语法转码为ES5的语法 es2016幂运算语法糖插件 2**3 =&gt; 2*2*2 es2017 Async / Await / Generator react 支持React编译 flow 支持静态类型检测编译 Babel-polyfill针对默认不转换的API，需要另外添加一个Polyfill，或针对某个API添加插件。 Babel 默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在 Array 对象上新增了 Array.from 方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill，为当前环境提供一个垫片。1npm install --save-dev babel-polyfill babel-polyfill 提提供了对新的标准API的支持，兼容老的版本。 下列特性需要使用 babel-polyfill 才能转码，或者单独引用相关插件 123456789101112131415161718192021222324252627282930313233343536373839404142// 数组操作ArrayBufferArray.fromArray.ofArray#copyWithinArray#fillArray#findArray#findIndexFunction#name// 数学方法Math.acoshMath.hypotMath.imul// 数字类型的扩展方法Number.isNaNNumber.isInteger// 对象的扩展方法Object.assignObject.getOwnPropertyDescriptorsObject.isObject.entriesObject.valuesObject.setPrototypeOfPromiseReflectRegExp#flags// 字符串的扩展方法String#codePointAtString#endsWithString.fromCodePointString#includesString.rawString#repeatString#startsWithString#padStartString#padEnd// 新扩展的数据类型MapSetSymbolWeakMapWeakSet 使用123import &apos;babel-polyfill&apos;;// 或者require(&apos;babel-polyfill&apos;); Stage说明Babel的转换级别依据 ES7不同阶段的语法提案设置了4个阶段：stage-0 、stage-1、stage-2、stage-3，使用时选装一个。（0的级别最高，包含的转码插件最多，往后越来越少） stage-0提供ES7的支持 包含 stage-1、stage-2、stage-3 的内容 特有的插件 transform-do-expressions transform-function-bind transform-do-expressions 支持 模板中使用if else12345678910111213&lt;div className=&quot;parents&quot;&gt;&#123; do &#123; if(color == &apos;blue&apos;) &#123; &lt;BlueComponent/&gt;; &#125;else if(color == &apos;red&apos;) &#123; &lt;RedComponent/&gt;; &#125;else &#123; &lt;GreenComponent/&gt;; &#125; &#125; &#125;&#125;&lt;/div&gt; transform-function-bind 绑定上下文 1234567891011121314151617181920212223242526272829303132// 语法obj::func // func.bind(obj)obj::func(val) // func.call(obj, val)::obj.func(val) // func.call(obj, val)// 基本用法const box = &#123; weight: 2, getWeight() &#123; return this.weight; &#125;,&#125;;const &#123; getWeight &#125; = box;console.log(box.getWeight()); // prints &apos;2&apos;const bigBox = &#123; weight: 10 &#125;;console.log(bigBox::getWeight()); // prints &apos;10&apos;// Can be chained:function add(val) &#123; return this + val; &#125;console.log(bigBox::getWeight()::add(5)); // prints &apos;15&apos;// 处理Nodelist(Array Like 类型)const &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll(&apos;a&apos;) ::map(node =&gt; node.href) ::filter(href =&gt; href.substring(0, 5) === &apos;https&apos;);console.log(sslUrls);// is equivalent toconst &#123; map, filter &#125; = Array.prototype;let sslUrls = document.querySelectorAll(&apos;a&apos;);sslUrls = map.call(sslUrls, node =&gt; node.href);sslUrls = filter.call(sslUrls, href =&gt; href.substring(0, 5) === &apos;https&apos;);console.log(sslUrls);//绑定自身$(&apos;.some-link&apos;).on(&apos;click&apos;, ::view.reset);// is equivalent to:$(&apos;.some-link&apos;).on(&apos;click&apos;, view.reset.bind(view)); stage-1包含 stage-2 、stage-3 提供对 类的静态、实例属性和方法的支持 以及 对模块导入方式的扩展 特有插件 transform-class-properties transform-export-extensions transform-class-properties 支持 123456789101112class Bork &#123; //Property initializer syntax instanceProperty = &quot;bork&quot;; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = &quot;babelIsCool&quot;; static staticFunction = function() &#123; return Bork.staticProperty; &#125;&#125; transform-class-properties 支持 12export * as ns from &apos;mod&apos;;export v from &apos;mod&apos;; stage-2包含 stage-3 提供尾逗号函数功能 及 支持 Object 使用延展符展开 特有插件 syntax-trailing-function-commas transform-object-reset-spread syntax-trailing-function-commas 添加行尾逗号，减少文件的改动12345678function clownPuppiesEverywhere( param1, param2,) &#123; /* ... */ &#125;clownPuppiesEverywhere( &apos;foo&apos;, &apos;bar&apos;,); transform-object-reset-spread 支持使用展开符展开对象1234567let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(x); // 1console.log(y); // 2console.log(z); // &#123; a: 3, b: 4 &#125;// 属性展开let n = &#123; x, y, ...z &#125;;console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125; stage-3提供对ES7的async和await的支持 及提供幂操作的语法糖 特有插件 transform-async-to-generator transform-exponentiation-operator transform-async-to-generator 转码ES7的 async与await12345678910111213141516//inasync function* agf() &#123; await 1; yield 2;&#125;//outvar _asyncGenerator = ...let agf = (() =&gt; &#123; var _ref = _asyncGenerator.wrap(function* () &#123; yield _asyncGenerator.await(1); yield 2; &#125;); return function agf() &#123; return _ref.apply(this, arguments); &#125;;&#125;)(); transform-exponentiation-operator 支持幂运算语法糖 **12345// x ** ylet squared = 2 ** 2;// 相当于: 2 * 2let cubed = 2 ** 3;// 相当于: 2 * 2 * 2 为了防止某些实验中的标准在未来不能定案，一般使用 stage-1 或 stage-2 来进行转码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-flow]]></title>
    <url>%2F2018%2F03%2F12%2Fwebpack-flow%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[关于继承继承，代码复用的一种模式。和其它高级程序语言相比，javascript有点点不一样，它是一门纯面向对象的语言，在JS中，没有类的概念，但也可以通过原型(prototype)来模拟对象的继承和多态。 原型与实例 一切对象都是Object的实例，一切函数都是Function的实例 构造函数通过 prototype 属性访问原型对象 实例对象通过 [[prototype]] 内部属性访问原型对象，浏览器实现了 proto 属性用于实例对象访问原型对象 Object 是构造函数，既然是函数，那么就是Function的实例对象；Function是构造函数，但Function.prototype是对象，既然是对象，那么就是Object的实例对象关系判断 instanceof 判断是否为另一个对象的实例 isPrototypeOf() 判断一个对象是否存在于另一个对象的原型链上 Child.isPrototypeOf(Parent) // true Object.getPrototypeOf() ES6中新增的方法，用于获取子类的父类 Object.getPrototypeOf(Child) == Parent // true继承类型 引用对象继承：子引用类型继承父引用类型，然后通过子引用类型生成的实例对象，具有父引用类型的特性。 实例对象继承：而实例对象继承，继承得到的对象都具有父实例对象的所有属性和方法，其实就是指对象的复制和克隆。引用对象继承 原型 （C.prototype = new P()） 构造函数 (P.apply(this, arguments)) 原型 + 构造函数 (使用原型链实现对原型中的属性方法的继承，使用构造函数实现实例属性的继承) 共享原型（子类与父类共享同一个原型） 临时原型（使用中间类） 临时原型 + 构造函数（完美、nodejs的继承方式、ES5版本）原型继承让子类的的原型等于父类的实例，从而继承父类的所有属性和原型1234567891011121314151617181920212223242526272829function Parent()&#123; this.name = &apos;father&apos;; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123;&#125;Person.prototype = new Parent();Person.prototype.constructor = Person;var p1 = new Person();var p2 = new Person();console.log(p1.name); // fatherconsole.log(p2.name); // fatherp1.name = &apos;jack&apos;;p2.name = &apos;mak&apos;;console.log(p1.name); // jackconsole.log(p2.name); // makconsole.log(p1.say()) // jack,[&quot;A&quot;, &quot;B&quot;]console.log(p2.say()) // mak,[&quot;A&quot;, &quot;B&quot;]console.log(&apos;====================&apos;)console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;]p1.friends.push(&apos;C&apos;);p1.friends.push(&apos;D&apos;);console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p1.say()) //jack,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.say()) //mak,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] 缺点： 不能向父类的构造函数中传递参数 父类中的引用类型属性会被实例共享 需要修正实例的constructor指向，否则会指向父类构造函数继承在子类的构造函数中使用 Parent.call(this, …args) 或 Parent.apply(this,[args]) 来继承父类的属性，并向父类的构造函数传参1234567891011121314151617181920function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123; Parent.apply(this, arguments); this.age = 23;&#125;var p1 = new Person(&apos;nameA&apos;);var p2 = new Person(&apos;nameB&apos;);console.log(p1.name); //nameAconsole.log(p2.name); //nameBp1.friends.push(&apos;C&apos;);p2.friends.push(&apos;D&apos;);console.log(p1.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]console.log(p2.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(p1.say()) // Uncaught TypeError: p1.say is not a function 优点：子类可以向父类的构造函数中传参，子类实例中的引用类型属性互不干扰 缺点：子类实例无法访问父类的原型（无法复用父类原型中的方法）原型+构造函数继承为解决纯原型继承不能给父传参和纯构造函数继承不能继承父类原型的缺点，把二者结合起来实现123456789101112131415161718192021222324252627function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; Parent.call(this, name); this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.see = function()&#123; console.log(this.age);&#125;Child.prototype.getAge = () =&gt; this.age;var c1 = new Child(&apos;jack&apos;,12);c1.friends.push(&apos;F&apos;);console.log(c1.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;F&quot;]console.log(c1.see()); //12var c2 = new Child(&apos;jack&apos;,42);c2.friends.push(&apos;D&apos;);console.log(c2.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(c2.see()); //42 缺点：子类初次实例化时会多调用一个父类的构造函数（第一次创建子类原型和子类实例化时） 共享原型子类和父类共用一个原型123456789101112131415161718192021function inherit(C, P)&#123; C.prototype = P.prototype;&#125;function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype.say=()=&gt;console.log(&apos;child&apos;,this.name);inherit(Child, Parent);var c1 = new Child(&apos;pake&apos;, 44);c1.name = &apos;jack&apos;;console.log(c1.name) //jackconsole.log(c1.say()) //jack,undefined 缺点：子类实例化时，父类构造函数接收不到参数， 子类原型如果改变也会影响到父类原型 临时原型使用一个纯净类继承父类的原型，再将纯净类的实例设置为子类的原型，如此子类继承了父类的原型和纯净类的构造函数，再修正一下子类的构造函数为子类本身，这样子类的原型改动就不影响父类。12345678910111213141516171819202122function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack undefined 缺点：只继承了父类的原型，子类实例化时一样不能给父类的构造函数传参 临时原型 + 构造函数在子类的构造函数中调用父类的构造函数，修复了上面 临时原型 不能传递参数给父类构造函数的问题123456789101112131415161718192021222324252627282930313233343536373839404142function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; Parent.call(this, age); this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack 10// 这种方法是最合适，也是用得最广的继承模式另一种相同的实现，ES5的实现function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info(&quot;Shape moved.&quot;);&#125;;function Rectangle() &#123; Shape.call(this); //call super constructor.&#125;Rectangle.prototype = Object.create(Shape.prototype);var rect = new Rectangle();console.log(rect instanceof Rectangle); //true.console.log(rect instanceof Shape); //true.rect.move(); //&quot;Shape moved.&quot; 实例对象继承原型实例创建一个继承父类原型的实例对象，这也是ES5中Object.create()的简单实现12345678910111213141516function object(P)&#123; var F = function()&#123;&#125;; F.prototype = P; return new F();&#125;function Parent(name) &#123; this.name = name || &apos;Adam&apos;;&#125;Parent.prototype.say = function()&#123; console.log(this.name)&#125;;var c1 = new Parent(&apos;jack&apos;);var c2 = object(c1);c2.name = &apos;mark&apos;;console.log(c1.say()) //jackconsole.log(c2.say()) //mark 克隆浅拷贝只能拷贝值类型的数据，对于引用类型，只会拷贝引用地址，如果有引用类型，多个拷贝对象会共用同一个引用类型的数据，造成混乱。123456789101112function clone(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; parent.hasOwnProperty(i) &amp;&amp; (child[i] = parent[i]); &#125; return child;&#125;var o1 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o2 = clone(o1);o2.arr.push(3);console.log(o1.arr); //[1, 2, 4, 3]console.log(o2.arr); //[1, 2, 4, 3] 两个拷贝对象共用同一个引用类型，会相互影响 深拷贝12345678910111213141516171819function cloneDeep(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i]===&apos;object&apos;)&#123; child[i] = Array.isArray(parent[i]) ? []:&#123;&#125;; cloneDeep(parent[i], child[i]); &#125;else&#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125;var o3 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o4 = cloneDeep(o3);o4.arr.push(3);console.log(o3.arr);//[1, 2, 4]console.log(o4.arr);//[1, 2, 4, 3] 两个对象引用不同的引用地址，互不影响 借用和绑定使用 call / apply / bind 复用对象上的方法12345678910111213141516171819202122232425var parent = &#123; name:&apos;parent&apos;, say:function(msg)&#123; console.log(this.name, msg) &#125;&#125;var child = &#123; name:&apos;child&apos;&#125;// 复用父类的say方法parent.say.call(child, &apos;hello&apos;); //child helloparent.say.bind(child, &apos;world&apos;)(); //child world// bind的内部实现if(typeof Function.prototype.bind === &apos;undefined&apos;)&#123; Function.prototype.bind = function(context)&#123; var _this = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function()&#123; return _this.apply(context, args.concat(slice.call(arguments))); &#125; &#125;&#125;// 借用Array中的slice方法// Array.prototype.slice.call() 与 [].prototype.slice.call() 区别: 前者写法长，但少一个创建数组实例的开销 ES6的继承方式使用 extends 关键字，来实现继承123456789101112131415161718192021222324252627282930class Parent &#123; static name = &apos;parent&apos;; //静态属性 work = &apos;aa&apos;; //实例属性&#125;class Child extends Parent &#123; constructor(age)&#123; super(age); // 在此必须先调用super()，否则子类实例化时会报错，因为子类没有自己的this对象，而是继承父类的this对象 this.age = age; &#125; say()&#123; console.log(&apos;child say&apos;, this.age); &#125; // 通过 static 关键字标识类的静态方法 static work()&#123; console.log(&apos;child working&apos;) &#125;&#125;Child.work(); //child workingvar c1 = new Child(16);console.log(c1.say());//child say 16// 如果子类中没有 constructor 方法，ES6 会默认添加这个方法constructor(...args)&#123; super(...args);&#125;class A extends Object&#123;&#125;A.__proto__ === Object //trueclass B extends Array&#123;&#125;var arrB = new B();b.push(1); //[1]b.length; //1 ES5继承 是先创建子类的实例对象this，再向this对象中添加父类的方法 ES6继承 是先创造父类的实例对象this, 再用子类的构造函数修改this Parent 可以是任意函数（只要有prototype属性）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.create与new的不同]]></title>
    <url>%2F2018%2F02%2F08%2FObject-create%E4%B8%8Enew%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。 语法1new constructor[([arguments])] 参数constructor一个指定对象实例的类型的函数。 arguments一个用来被constructor 调用的参数列表。 描述创建一个用户自定义的对象需要两步： 1.定义构造函数。2.通过new来创建对象实例。 创建一个对象类型需要创建一个指定了名称和属性的函数；其中这些属性可以指向它本身，也可以指向其他对象，看下面的例子： 当代码 new Foo(…) 执行时： 1.一个新对象被创建。它继承自Foo.prototype。2.使用指定的参数调用构造函数Foo，并将 this绑定到新创建的对象。new Foo 等同于 new Foo()，只能用在Foo 不传递任何参数的情况。3.如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。） 任何情况下都可以对任意一个对象添加新的属性，例如 car1.color = “black” 语句给car1添加了一个新的属性color , 然后给这个属性赋值 “black”。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，必须将该属性添加到Car对象类型的定义中。 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 语法1Object.create(proto[, propertiesObject]) 参数proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值在指定原型对象上添加新属性后的对象。 例外如果proto参数不是 null 或一个对象，则抛出一个 TypeError 异常。 以上是MDN上对new操作符和Object.create的定义 下面再来看看执行这两个操作分别都做了什么12//new 操作符var a = new Foo(); 1234const o = new Object();//创建了一个新的空对象oo.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`Foo.call(o);//this指向o对象a = o;//将o对象赋给a对象 12//Object.createvar a = Object.create(Foo); 12345Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F();&#125;; 当看到结果的时候我是一脸懵逼,属性和原型方法都没有继承下来!!! 没事,咱们来画个图 这下就清楚了,在用Object.create创建的对象b把__proto__指向了Foo构造函数本身,再回来理解MDN的定义就明白了 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 1b.__proto__ === Foo //true 总结：1.Object.create在创建新对象时把__proto__指向了传进来的参数对象，这个参数可以是任何对象。而new操作符只能是由构造函数创建对象。2.new操作符会在执行过程中调用构造函数并把this指向新对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 7配置samba]]></title>
    <url>%2F2018%2F02%2F08%2FcentOS%207%E9%85%8D%E7%BD%AEsamba%2F</url>
    <content type="text"><![CDATA[（以下内容均来自网络学习） root用户执行 安装Samba12yum -y install samba samba-client samba-common rpm -qi samba可以查看samba版本信息 12345678910111213141516171819202122[root@MiWiFi-R1CM-srv samba]# rpm -qi sambaName : sambaEpoch : 0Version : 4.2.10Release : 6.2.el7_2Architecture: x86_64Install Date: Tue 19 Jul 2016 03:26:55 AM CSTGroup : System Environment/DaemonsSize : 1895784License : GPLv3+ and LGPLv3+Signature : RSA/SHA256, Fri 24 Jun 2016 04:12:11 AM CST, Key ID 24c6a8a7f4a80eb5Source RPM : samba-4.2.10-6.2.el7_2.src.rpmBuild Date : Fri 24 Jun 2016 02:38:45 AM CSTBuild Host : worker1.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor : CentOSURL : http://www.samba.org/Summary : Server and Client software to interoperate with Windows machinesDescription :Samba is the standard Windows interoperability suite of programs for Linux and Unix.[root@MiWiFi-R1CM-srv samba]# 设置开机启动：1systemctl enable smb.service 查看是否设置成功1systemctl status smb.service 启动samba服务1systemctl start smb.service 再次查看启动状态1systemctl status smb.service 1234567891011121314151617[root@MiWiFi-R1CM-srv samba]# systemctl status smb.service● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2016-07-19 03:32:36 CST; 12min ago Main PID: 27455 (smbd) Status: &quot;smbd: ready to serve connections...&quot; CGroup: /system.slice/smb.service ├─27455 /usr/sbin/smbd ├─27460 /usr/sbin/smbd └─27601 /usr/sbin/smbdJul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Starting Samba SMB Daemon...Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: smb.service: Supervising process 27455 which is not our child. We&apos;ll most likely not n... exits.Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Started Samba SMB Daemon.Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: [2016/07/19 03:32:36.184968, 0] ../lib/util/become_daemon.c:124(daemon_ready)Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: STATUS=daemon &apos;smbd&apos; finished starting up and ready to serve connectionsHint: Some lines were ellipsized, use -l to show in full.[root@MiWiFi-R1CM-srv samba]# 配置配置文件进入目录：1cd /etc/samba 备份：1# cp smb.conf smb.conf.backup 修改smb.conf文件，找到“[homes]”，修改以下设置：12345678910111213[global] log file = /var/log/samba/log.%m load printers = yes cups options = raw server string = Samba Server Version %v writeable = yes force directory mode = 777 force create mode = 777 workgroup = MYGROUP security = user create mode = 777 passdb backend = tdbsam max log size = 50 新版的samba放在smb.conf最后是无效的 添加用户1smbpasswd -a username 如果出现bash: smbpasswd: command not found，就是没有安装samba-client了 附： smbpasswd命令的常用方法123456789smbpasswd -a 增加用户（要增加的用户必须以是系统用户）smbpasswd -d 冻结用户，就是这个用户不能在登录了smbpasswd -e 恢复用户，解冻用户，让冻结的用户可以在使用smbpasswd -n 把用户的密码设置成空.要在global中写入 null passwords -truesmbpasswd -x 删除用户 selinux设置12getsebool -a | grep sambasetsebool -P samba_enable_home_dirs on 防火墙，使用新的防火墙firewall添加就可以，比iptables更方便1234firewall-cmd --list-servicesfirewall-cmd --permanent --add-service=sambafirewall-cmd --reloadfirewall-cmd --list-services 由于redhat7开始，iptables被firewalld代替了，所以使用firewalld的方法 关于firewalld的说明，可以看fedora官网介绍 https://fedoraproject.org/wiki/FirewallD/zh-cn 1重启samba服务1systemctl restart smb.service]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数运算初探]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[之前再做大数运算的时候在网上查到一个高大上的方法1234567891011function sumStrings(a,b)&#123; var res=&apos;&apos;, c=0; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c)&#123; c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c&gt;9; &#125; return res.replace(/^0+/,&apos;&apos;);&#125; 逼格满满 虽然之前也见过这些操作符,但是一直都没有研究过,今天就来了解一下先来看看~是什么 位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。 位运算 NOT 是三步的处理过程： 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 举个栗子：~8 =&gt; 1000 =&gt; 取反 =&gt; 符号位为1 0111 =&gt; 负数取反符号位不变 =&gt; 符号位1 1000 =&gt; 补码 =&gt; 符号位1 1001 =&gt; -9 在MDN查到这么一句 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 这对之后的运算就可以省去很多步骤了 再回来看上面的add方法大致的逻辑是 字符串转成数组,每位一个元素 然后把数组最后一位揪出来 做两次取反的计算 因为位运算会对运算数转成32位数字，所以根据尝试对~操作前的流程做了一定的猜测首先先对运算数进行隐式的转换Nuber()，如果是NaN的话会转成0 经过查看规范证实上面的猜测 所以经过取反以后,数字字符串会直接转成数字，undefined会直接转成0，就可以进行下面的计算了 经过测试呢，~~确实比Math.floor性能强那么有限的一点12345678910111213console.time(&apos;~&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; ~~14.14;&#125;console.timeEnd(&apos;~&apos;)~: 2.107177734375msconsole.time(&apos;Math.floor&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; Math.floor(14.14)&#125;console.timeEnd(&apos;Math.floor&apos;)Math.floor: 3.206787109375ms 总结：装逼神器]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

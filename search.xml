<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[关于继承继承，代码复用的一种模式。和其它高级程序语言相比，javascript有点点不一样，它是一门纯面向对象的语言，在JS中，没有类的概念，但也可以通过原型(prototype)来模拟对象的继承和多态。 原型与实例 一切对象都是Object的实例，一切函数都是Function的实例 构造函数通过 prototype 属性访问原型对象 实例对象通过 [[prototype]] 内部属性访问原型对象，浏览器实现了 proto 属性用于实例对象访问原型对象 Object 是构造函数，既然是函数，那么就是Function的实例对象；Function是构造函数，但Function.prototype是对象，既然是对象，那么就是Object的实例对象关系判断 instanceof 判断是否为另一个对象的实例 isPrototypeOf() 判断一个对象是否存在于另一个对象的原型链上 Child.isPrototypeOf(Parent) // true Object.getPrototypeOf() ES6中新增的方法，用于获取子类的父类 Object.getPrototypeOf(Child) == Parent // true继承类型 引用对象继承：子引用类型继承父引用类型，然后通过子引用类型生成的实例对象，具有父引用类型的特性。 实例对象继承：而实例对象继承，继承得到的对象都具有父实例对象的所有属性和方法，其实就是指对象的复制和克隆。引用对象继承 原型 （C.prototype = new P()） 构造函数 (P.apply(this, arguments)) 原型 + 构造函数 (使用原型链实现对原型中的属性方法的继承，使用构造函数实现实例属性的继承) 共享原型（子类与父类共享同一个原型） 临时原型（使用中间类） 临时原型 + 构造函数（完美、nodejs的继承方式、ES5版本）原型继承让子类的的原型等于父类的实例，从而继承父类的所有属性和原型1234567891011121314151617181920212223242526272829function Parent()&#123; this.name = &apos;father&apos;; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123;&#125;Person.prototype = new Parent();Person.prototype.constructor = Person;var p1 = new Person();var p2 = new Person();console.log(p1.name); // fatherconsole.log(p2.name); // fatherp1.name = &apos;jack&apos;;p2.name = &apos;mak&apos;;console.log(p1.name); // jackconsole.log(p2.name); // makconsole.log(p1.say()) // jack,[&quot;A&quot;, &quot;B&quot;]console.log(p2.say()) // mak,[&quot;A&quot;, &quot;B&quot;]console.log(&apos;====================&apos;)console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;]p1.friends.push(&apos;C&apos;);p1.friends.push(&apos;D&apos;);console.log(p1.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.friends); //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p1.say()) //jack,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]console.log(p2.say()) //mak,[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] 缺点： 不能向父类的构造函数中传递参数 父类中的引用类型属性会被实例共享 需要修正实例的constructor指向，否则会指向父类构造函数继承在子类的构造函数中使用 Parent.call(this, …args) 或 Parent.apply(this,[args]) 来继承父类的属性，并向父类的构造函数传参1234567891011121314151617181920function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;];&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Person()&#123; Parent.apply(this, arguments); this.age = 23;&#125;var p1 = new Person(&apos;nameA&apos;);var p2 = new Person(&apos;nameB&apos;);console.log(p1.name); //nameAconsole.log(p2.name); //nameBp1.friends.push(&apos;C&apos;);p2.friends.push(&apos;D&apos;);console.log(p1.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]console.log(p2.friends) //[&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(p1.say()) // Uncaught TypeError: p1.say is not a function 优点：子类可以向父类的构造函数中传参，子类实例中的引用类型属性互不干扰 缺点：子类实例无法访问父类的原型（无法复用父类原型中的方法）原型+构造函数继承为解决纯原型继承不能给父传参和纯构造函数继承不能继承父类原型的缺点，把二者结合起来实现123456789101112131415161718192021222324252627function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; Parent.call(this, name); this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.see = function()&#123; console.log(this.age);&#125;Child.prototype.getAge = () =&gt; this.age;var c1 = new Child(&apos;jack&apos;,12);c1.friends.push(&apos;F&apos;);console.log(c1.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;F&quot;]console.log(c1.see()); //12var c2 = new Child(&apos;jack&apos;,42);c2.friends.push(&apos;D&apos;);console.log(c2.say()); //jack [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;]console.log(c2.see()); //42 缺点：子类初次实例化时会多调用一个父类的构造函数（第一次创建子类原型和子类实例化时） 共享原型子类和父类共用一个原型123456789101112131415161718192021function inherit(C, P)&#123; C.prototype = P.prototype;&#125;function Parent(name)&#123; this.name = name; this.friends = [&apos;A&apos;,&apos;B&apos;]; console.log(&apos;Parent constructor excuted&apos;);&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.friends)&#125;function Child(name, age)&#123; this.age = age; console.log(&apos;Child constructor excuted&apos;);&#125;Child.prototype.say=()=&gt;console.log(&apos;child&apos;,this.name);inherit(Child, Parent);var c1 = new Child(&apos;pake&apos;, 44);c1.name = &apos;jack&apos;;console.log(c1.name) //jackconsole.log(c1.say()) //jack,undefined 缺点：子类实例化时，父类构造函数接收不到参数， 子类原型如果改变也会影响到父类原型 临时原型使用一个纯净类继承父类的原型，再将纯净类的实例设置为子类的原型，如此子类继承了父类的原型和纯净类的构造函数，再修正一下子类的构造函数为子类本身，这样子类的原型改动就不影响父类。12345678910111213141516171819202122function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack undefined 缺点：只继承了父类的原型，子类实例化时一样不能给父类的构造函数传参 临时原型 + 构造函数在子类的构造函数中调用父类的构造函数，修复了上面 临时原型 不能传递参数给父类构造函数的问题123456789101112131415161718192021222324252627282930313233343536373839404142function inherit(C, P)&#123; function F()&#123;&#125; F.prototype = P.prototype; C.prototype = new F(); //继承父类的原型，但不继承父类的构造函数 C.super = P.prototype; //便于子类访问父类的原型 C.prototype.constructor = C; //重置构造函数为本身 return new F();&#125;function Parent (age)&#123; this.name = &apos;parent&apos;; this.age = age || 50;&#125;Parent.prototype.say = function()&#123; console.log(this.name, this.age)&#125;function Child (name, age)&#123; Parent.call(this, age); this.name = name;&#125;inherit(Child, Parent)var c1 = new Child(&apos;jack&apos;, 10)console.log(c1.name) // jackconsole.log( c1.say() ) // jack 10// 这种方法是最合适，也是用得最广的继承模式另一种相同的实现，ES5的实现function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info(&quot;Shape moved.&quot;);&#125;;function Rectangle() &#123; Shape.call(this); //call super constructor.&#125;Rectangle.prototype = Object.create(Shape.prototype);var rect = new Rectangle();console.log(rect instanceof Rectangle); //true.console.log(rect instanceof Shape); //true.rect.move(); //&quot;Shape moved.&quot; 实例对象继承原型实例创建一个继承父类原型的实例对象，这也是ES5中Object.create()的简单实现12345678910111213141516function object(P)&#123; var F = function()&#123;&#125;; F.prototype = P; return new F();&#125;function Parent(name) &#123; this.name = name || &apos;Adam&apos;;&#125;Parent.prototype.say = function()&#123; console.log(this.name)&#125;;var c1 = new Parent(&apos;jack&apos;);var c2 = object(c1);c2.name = &apos;mark&apos;;console.log(c1.say()) //jackconsole.log(c2.say()) //mark 克隆浅拷贝只能拷贝值类型的数据，对于引用类型，只会拷贝引用地址，如果有引用类型，多个拷贝对象会共用同一个引用类型的数据，造成混乱。123456789101112function clone(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; parent.hasOwnProperty(i) &amp;&amp; (child[i] = parent[i]); &#125; return child;&#125;var o1 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o2 = clone(o1);o2.arr.push(3);console.log(o1.arr); //[1, 2, 4, 3]console.log(o2.arr); //[1, 2, 4, 3] 两个拷贝对象共用同一个引用类型，会相互影响 深拷贝12345678910111213141516171819function cloneDeep(parent, child)&#123; var i, child = child || &#123;&#125;; for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i]===&apos;object&apos;)&#123; child[i] = Array.isArray(parent[i]) ? []:&#123;&#125;; cloneDeep(parent[i], child[i]); &#125;else&#123; child[i] = parent[i]; &#125; &#125; &#125; return child;&#125;var o3 = &#123; arr: [1,2,4], name:&apos;jack&apos;&#125;;var o4 = cloneDeep(o3);o4.arr.push(3);console.log(o3.arr);//[1, 2, 4]console.log(o4.arr);//[1, 2, 4, 3] 两个对象引用不同的引用地址，互不影响 借用和绑定使用 call / apply / bind 复用对象上的方法12345678910111213141516171819202122232425var parent = &#123; name:&apos;parent&apos;, say:function(msg)&#123; console.log(this.name, msg) &#125;&#125;var child = &#123; name:&apos;child&apos;&#125;// 复用父类的say方法parent.say.call(child, &apos;hello&apos;); //child helloparent.say.bind(child, &apos;world&apos;)(); //child world// bind的内部实现if(typeof Function.prototype.bind === &apos;undefined&apos;)&#123; Function.prototype.bind = function(context)&#123; var _this = this, slice = Array.prototype.slice, args = slice.call(arguments, 1); return function()&#123; return _this.apply(context, args.concat(slice.call(arguments))); &#125; &#125;&#125;// 借用Array中的slice方法// Array.prototype.slice.call() 与 [].prototype.slice.call() 区别: 前者写法长，但少一个创建数组实例的开销 ES6的继承方式使用 extends 关键字，来实现继承123456789101112131415161718192021222324252627282930class Parent &#123; static name = &apos;parent&apos;; //静态属性 work = &apos;aa&apos;; //实例属性&#125;class Child extends Parent &#123; constructor(age)&#123; super(age); // 在此必须先调用super()，否则子类实例化时会报错，因为子类没有自己的this对象，而是继承父类的this对象 this.age = age; &#125; say()&#123; console.log(&apos;child say&apos;, this.age); &#125; // 通过 static 关键字标识类的静态方法 static work()&#123; console.log(&apos;child working&apos;) &#125;&#125;Child.work(); //child workingvar c1 = new Child(16);console.log(c1.say());//child say 16// 如果子类中没有 constructor 方法，ES6 会默认添加这个方法constructor(...args)&#123; super(...args);&#125;class A extends Object&#123;&#125;A.__proto__ === Object //trueclass B extends Array&#123;&#125;var arrB = new B();b.push(1); //[1]b.length; //1 ES5继承 是先创建子类的实例对象this，再向this对象中添加父类的方法 ES6继承 是先创造父类的实例对象this, 再用子类的构造函数修改this Parent 可以是任意函数（只要有prototype属性）]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.create与new的不同]]></title>
    <url>%2F2018%2F02%2F08%2FObject-create%E4%B8%8Enew%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。 语法1new constructor[([arguments])] 参数constructor一个指定对象实例的类型的函数。 arguments一个用来被constructor 调用的参数列表。 描述创建一个用户自定义的对象需要两步： 1.定义构造函数。2.通过new来创建对象实例。 创建一个对象类型需要创建一个指定了名称和属性的函数；其中这些属性可以指向它本身，也可以指向其他对象，看下面的例子： 当代码 new Foo(…) 执行时： 1.一个新对象被创建。它继承自Foo.prototype。2.使用指定的参数调用构造函数Foo，并将 this绑定到新创建的对象。new Foo 等同于 new Foo()，只能用在Foo 不传递任何参数的情况。3.如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。） 任何情况下都可以对任意一个对象添加新的属性，例如 car1.color = “black” 语句给car1添加了一个新的属性color , 然后给这个属性赋值 “black”。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，必须将该属性添加到Car对象类型的定义中。 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 语法1Object.create(proto[, propertiesObject]) 参数proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值在指定原型对象上添加新属性后的对象。 例外如果proto参数不是 null 或一个对象，则抛出一个 TypeError 异常。 以上是MDN上对new操作符和Object.create的定义 下面再来看看执行这两个操作分别都做了什么12//new 操作符var a = new Foo(); 1234const o = new Object();//创建了一个新的空对象oo.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`Foo.call(o);//this指向o对象a = o;//将o对象赋给a对象 12//Object.createvar a = Object.create(Foo); 12345Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F();&#125;; 当看到结果的时候我是一脸懵逼,属性和原型方法都没有继承下来!!! 没事,咱们来画个图 这下就清楚了,在用Object.create创建的对象b把__proto__指向了Foo构造函数本身,再回来理解MDN的定义就明白了 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 1b.__proto__ === Foo //true 总结：1.Object.create在创建新对象时把__proto__指向了传进来的参数对象，这个参数可以是任何对象。而new操作符只能是由构造函数创建对象。2.new操作符会在执行过程中调用构造函数并把this指向新对象]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 7配置samba]]></title>
    <url>%2F2018%2F02%2F08%2FcentOS%207%E9%85%8D%E7%BD%AEsamba%2F</url>
    <content type="text"><![CDATA[（以下内容均来自网络学习） root用户执行 安装Samba12yum -y install samba samba-client samba-common rpm -qi samba可以查看samba版本信息 12345678910111213141516171819202122[root@MiWiFi-R1CM-srv samba]# rpm -qi sambaName : sambaEpoch : 0Version : 4.2.10Release : 6.2.el7_2Architecture: x86_64Install Date: Tue 19 Jul 2016 03:26:55 AM CSTGroup : System Environment/DaemonsSize : 1895784License : GPLv3+ and LGPLv3+Signature : RSA/SHA256, Fri 24 Jun 2016 04:12:11 AM CST, Key ID 24c6a8a7f4a80eb5Source RPM : samba-4.2.10-6.2.el7_2.src.rpmBuild Date : Fri 24 Jun 2016 02:38:45 AM CSTBuild Host : worker1.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor : CentOSURL : http://www.samba.org/Summary : Server and Client software to interoperate with Windows machinesDescription :Samba is the standard Windows interoperability suite of programs for Linux and Unix.[root@MiWiFi-R1CM-srv samba]# 设置开机启动：1systemctl enable smb.service 查看是否设置成功1systemctl status smb.service 启动samba服务1systemctl start smb.service 再次查看启动状态1systemctl status smb.service 1234567891011121314151617[root@MiWiFi-R1CM-srv samba]# systemctl status smb.service● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2016-07-19 03:32:36 CST; 12min ago Main PID: 27455 (smbd) Status: &quot;smbd: ready to serve connections...&quot; CGroup: /system.slice/smb.service ├─27455 /usr/sbin/smbd ├─27460 /usr/sbin/smbd └─27601 /usr/sbin/smbdJul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Starting Samba SMB Daemon...Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: smb.service: Supervising process 27455 which is not our child. We&apos;ll most likely not n... exits.Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Started Samba SMB Daemon.Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: [2016/07/19 03:32:36.184968, 0] ../lib/util/become_daemon.c:124(daemon_ready)Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: STATUS=daemon &apos;smbd&apos; finished starting up and ready to serve connectionsHint: Some lines were ellipsized, use -l to show in full.[root@MiWiFi-R1CM-srv samba]# 配置配置文件进入目录：1cd /etc/samba 备份：1# cp smb.conf smb.conf.backup 修改smb.conf文件，找到“[homes]”，修改以下设置：12345678910111213[global] log file = /var/log/samba/log.%m load printers = yes cups options = raw server string = Samba Server Version %v writeable = yes force directory mode = 777 force create mode = 777 workgroup = MYGROUP security = user create mode = 777 passdb backend = tdbsam max log size = 50 新版的samba放在smb.conf最后是无效的 添加用户1smbpasswd -a username 如果出现bash: smbpasswd: command not found，就是没有安装samba-client了 附： smbpasswd命令的常用方法123456789smbpasswd -a 增加用户（要增加的用户必须以是系统用户）smbpasswd -d 冻结用户，就是这个用户不能在登录了smbpasswd -e 恢复用户，解冻用户，让冻结的用户可以在使用smbpasswd -n 把用户的密码设置成空.要在global中写入 null passwords -truesmbpasswd -x 删除用户 selinux设置12getsebool -a | grep sambasetsebool -P samba_enable_home_dirs on 防火墙，使用新的防火墙firewall添加就可以，比iptables更方便1234firewall-cmd --list-servicesfirewall-cmd --permanent --add-service=sambafirewall-cmd --reloadfirewall-cmd --list-services 由于redhat7开始，iptables被firewalld代替了，所以使用firewalld的方法 关于firewalld的说明，可以看fedora官网介绍 https://fedoraproject.org/wiki/FirewallD/zh-cn 1重启samba服务1systemctl restart smb.service]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数运算初探]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[之前再做大数运算的时候在网上查到一个高大上的方法1234567891011function sumStrings(a,b)&#123; var res=&apos;&apos;, c=0; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c)&#123; c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c&gt;9; &#125; return res.replace(/^0+/,&apos;&apos;);&#125; 逼格满满 虽然之前也见过这些操作符,但是一直都没有研究过,今天就来了解一下先来看看~是什么 位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。 位运算 NOT 是三步的处理过程： 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 举个栗子：~8 =&gt; 1000 =&gt; 取反 =&gt; 符号位为1 0111 =&gt; 负数取反符号位不变 =&gt; 符号位1 1000 =&gt; 补码 =&gt; 符号位1 1001 =&gt; -9 在MDN查到这么一句 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 这对之后的运算就可以省去很多步骤了 再回来看上面的add方法大致的逻辑是 字符串转成数组,每位一个元素 然后把数组最后一位揪出来 做两次取反的计算 因为位运算会对运算数转成32位数字，所以根据尝试对~操作前的流程做了一定的猜测首先先对运算数进行隐式的转换Nuber()，如果是NaN的话会转成0 经过查看规范证实上面的猜测 所以经过取反以后,数字字符串会直接转成数字，undefined会直接转成0，就可以进行下面的计算了 经过测试呢，~~确实比Math.floor性能强那么有限的一点12345678910111213console.time(&apos;~&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; ~~14.14;&#125;console.timeEnd(&apos;~&apos;)~: 2.107177734375msconsole.time(&apos;Math.floor&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; Math.floor(14.14)&#125;console.timeEnd(&apos;Math.floor&apos;)Math.floor: 3.206787109375ms 总结：装逼神器]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object.create与new的不同]]></title>
    <url>%2F2018%2F02%2F08%2FObject-create%E4%B8%8Enew%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。 语法1new constructor[([arguments])] 参数constructor一个指定对象实例的类型的函数。 arguments一个用来被constructor 调用的参数列表。 描述创建一个用户自定义的对象需要两步： 1.定义构造函数。2.通过new来创建对象实例。 创建一个对象类型需要创建一个指定了名称和属性的函数；其中这些属性可以指向它本身，也可以指向其他对象，看下面的例子： 当代码 new Foo(…) 执行时： 1.一个新对象被创建。它继承自Foo.prototype。2.使用指定的参数调用构造函数Foo，并将 this绑定到新创建的对象。new Foo 等同于 new Foo()，只能用在Foo 不传递任何参数的情况。3.如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。） 任何情况下都可以对任意一个对象添加新的属性，例如 car1.color = “black” 语句给car1添加了一个新的属性color , 然后给这个属性赋值 “black”。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，必须将该属性添加到Car对象类型的定义中。 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 语法1Object.create(proto[, propertiesObject]) 参数proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值在指定原型对象上添加新属性后的对象。 例外如果proto参数不是 null 或一个对象，则抛出一个 TypeError 异常。 以上是MDN上对new操作符和Object.create的定义 下面再来看看执行这两个操作分别都做了什么12//new 操作符var a = new Foo(); 1234const o = new Object();//创建了一个新的空对象oo.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`Foo.call(o);//this指向o对象a = o;//将o对象赋给a对象 12//Object.createvar a = Object.create(Foo); 12345Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F();&#125;; 当看到结果的时候我是一脸懵逼,属性和原型方法都没有继承下来!!! 没事,咱们来画个图 这下就清楚了,在用Object.create创建的对象b把__proto__指向了Foo构造函数本身,再回来理解MDN的定义就明白了 Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。 1b.__proto__ === Foo //true 总结：1.Object.create在创建新对象时把__proto__指向了传进来的参数对象，这个参数可以是任何对象。而new操作符只能是由构造函数创建对象。2.new操作符会在执行过程中调用构造函数并把this指向新对象]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos 7配置samba]]></title>
    <url>%2F2018%2F02%2F08%2F7%E9%85%8D%E7%BD%AEsamba%2F</url>
    <content type="text"><![CDATA[（以下内容均来自网络学习） root用户执行 1. 安装Samba12yum -y install samba samba-client samba-common rpm -qi samba可以查看samba版本信息 12345678910111213141516171819202122[root@MiWiFi-R1CM-srv samba]# rpm -qi sambaName : sambaEpoch : 0Version : 4.2.10Release : 6.2.el7_2Architecture: x86_64Install Date: Tue 19 Jul 2016 03:26:55 AM CSTGroup : System Environment/DaemonsSize : 1895784License : GPLv3+ and LGPLv3+Signature : RSA/SHA256, Fri 24 Jun 2016 04:12:11 AM CST, Key ID 24c6a8a7f4a80eb5Source RPM : samba-4.2.10-6.2.el7_2.src.rpmBuild Date : Fri 24 Jun 2016 02:38:45 AM CSTBuild Host : worker1.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor : CentOSURL : http://www.samba.org/Summary : Server and Client software to interoperate with Windows machinesDescription :Samba is the standard Windows interoperability suite of programs for Linux and Unix.[root@MiWiFi-R1CM-srv samba]# 2. 设置开机启动：1systemctl enable smb.service 3. 查看是否设置成功1systemctl status smb.service 4. 启动samba服务1systemctl start smb.service 5. 再次查看启动状态1systemctl status smb.service 1234567891011121314151617[root@MiWiFi-R1CM-srv samba]# systemctl status smb.service● smb.service - Samba SMB Daemon Loaded: loaded (/usr/lib/systemd/system/smb.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2016-07-19 03:32:36 CST; 12min ago Main PID: 27455 (smbd) Status: &quot;smbd: ready to serve connections...&quot; CGroup: /system.slice/smb.service ├─27455 /usr/sbin/smbd ├─27460 /usr/sbin/smbd └─27601 /usr/sbin/smbdJul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Starting Samba SMB Daemon...Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: smb.service: Supervising process 27455 which is not our child. We&apos;ll most likely not n... exits.Jul 19 03:32:36 MiWiFi-R1CM-srv systemd[1]: Started Samba SMB Daemon.Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: [2016/07/19 03:32:36.184968, 0] ../lib/util/become_daemon.c:124(daemon_ready)Jul 19 03:32:36 MiWiFi-R1CM-srv smbd[27455]: STATUS=daemon &apos;smbd&apos; finished starting up and ready to serve connectionsHint: Some lines were ellipsized, use -l to show in full.[root@MiWiFi-R1CM-srv samba]# 6. 配置配置文件进入目录：1cd /etc/samba 备份：1# cp smb.conf smb.conf.backup 修改smb.conf文件，找到“[homes]”，修改以下设置：12345678910111213[global] log file = /var/log/samba/log.%m load printers = yes cups options = raw server string = Samba Server Version %v writeable = yes force directory mode = 777 force create mode = 777 workgroup = MYGROUP security = user create mode = 777 passdb backend = tdbsam max log size = 50 新版的samba放在smb.conf最后是无效的 7. 添加用户1smbpasswd -a username 如果出现bash: smbpasswd: command not found，就是没有安装samba-client了 附： smbpasswd命令的常用方法123456789smbpasswd -a 增加用户（要增加的用户必须以是系统用户）smbpasswd -d 冻结用户，就是这个用户不能在登录了smbpasswd -e 恢复用户，解冻用户，让冻结的用户可以在使用smbpasswd -n 把用户的密码设置成空.要在global中写入 null passwords -truesmbpasswd -x 删除用户 8. selinux设置12getsebool -a | grep sambasetsebool -P samba_enable_home_dirs on 9. 防火墙，使用新的防火墙firewall添加就可以，比iptables更方便1234firewall-cmd --list-servicesfirewall-cmd --permanent --add-service=sambafirewall-cmd --reloadfirewall-cmd --list-services 由于redhat7开始，iptables被firewalld代替了，所以使用firewalld的方法 关于firewalld的说明，可以看fedora官网介绍 https://fedoraproject.org/wiki/FirewallD/zh-cn 10. 重启samba服务1systemctl restart smb.service]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数运算初探]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[之前再做大数运算的时候在网上查到一个高大上的方法1234567891011function sumStrings(a,b)&#123; var res=&apos;&apos;, c=0; a = a.split(&apos;&apos;); b = b.split(&apos;&apos;); while (a.length || b.length || c)&#123; c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c&gt;9; &#125; return res.replace(/^0+/,&apos;&apos;);&#125; 逼格满满 虽然之前也见过这些操作符,但是一直都没有研究过,今天就来了解一下先来看看~是什么 位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。 位运算 NOT 是三步的处理过程： 把运算数转换成 32 位数字 把二进制数转换成它的二进制反码 把二进制数转换成浮点数 举个栗子：~8 =&gt; 1000 =&gt; 取反 =&gt; 符号位为1 0111 =&gt; 负数取反符号位不变 =&gt; 符号位1 1000 =&gt; 补码 =&gt; 符号位1 1001 =&gt; -9 在MDN查到这么一句 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 这对之后的运算就可以省去很多步骤了 再回来看上面的add方法大致的逻辑是 字符串转成数组,每位一个元素 然后把数组最后一位揪出来 做两次取反的计算 因为位运算会对运算数转成32位数字，所以根据尝试对~操作前的流程做了一定的猜测首先先对运算数进行隐式的转换Nuber()，如果是NaN的话会转成0 经过查看规范证实上面的猜测 所以经过取反以后,数字字符串会直接转成数字，undefined会直接转成0，就可以进行下面的计算了 经过测试呢，~~确实比Math.floor性能强那么有限的一点12345678910111213console.time(&apos;~&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; ~~14.14;&#125;console.timeEnd(&apos;~&apos;)~: 2.107177734375msconsole.time(&apos;Math.floor&apos;)for(let i = 0; i &lt; 1000000; i++)&#123; Math.floor(14.14)&#125;console.timeEnd(&apos;Math.floor&apos;)Math.floor: 3.206787109375ms 总结：装逼神器]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
